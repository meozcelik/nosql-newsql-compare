import { getCockroachDBClient, getMongoDB } from './dbConnectors';

/**
 * Simulate SQL Injection attempt on CockroachDB
 * This demonstrates how parameterized queries protect against SQL injection
 */
export async function simulateSQLInjection(userInput: string): Promise<{
  vulnerable: boolean;
  result: any;
  message: string;
}> {
  const client = getCockroachDBClient();
  if (!client) {
    throw new Error('CockroachDB client not initialized');
  }

  try {
    // VULNERABLE WAY (DO NOT USE IN PRODUCTION) - Direct string interpolation
    // This would be vulnerable: `SELECT * FROM test_data WHERE name = '${userInput}'`
    
    // SAFE WAY - Using parameterized queries
    // Even if userInput contains SQL injection code like: "'; DROP TABLE test_data; --"
    // The parameterized query will treat it as a literal string value
    
    const safeQuery = 'SELECT * FROM test_data WHERE name = $1 LIMIT 10';
    const result = await client.query(safeQuery, [userInput]);

    return {
      vulnerable: false,
      result: result.rows,
      message: 'Parameterized query protected against SQL injection. The malicious input was treated as a literal string value.',
    };
  } catch (error: any) {
    return {
      vulnerable: false,
      result: null,
      message: `Error: ${error.message}. The parameterized query prevented execution of malicious code.`,
    };
  }
}

/**
 * Simulate NoSQL Injection attempt on MongoDB
 * This demonstrates how parameterized queries protect against NoSQL injection
 */
export async function simulateNoSQLInjection(userInput: string): Promise<{
  vulnerable: boolean;
  result: any;
  message: string;
}> {
  const db = getMongoDB();
  if (!db) {
    throw new Error('MongoDB client not initialized');
  }

  try {
    const collection = db.collection('test_data');

    // VULNERABLE WAY (DO NOT USE IN PRODUCTION) - Direct object construction
    // This would be vulnerable: collection.find({ name: userInput })
    // If userInput is: { $ne: null } or { $gt: "" }, it could bypass filters
    
    // SAFE WAY - Using explicit query construction
    // Even if userInput contains MongoDB operators like: { $ne: null }
    // We explicitly construct the query object
    
    const safeQuery = { name: userInput };
    const result = await collection.find(safeQuery).limit(10).toArray();

    // Additional protection: Validate userInput is a string
    if (typeof userInput !== 'string') {
      return {
        vulnerable: false,
        result: null,
        message: 'Input validation prevented NoSQL injection. Expected string type.',
      };
    }

    return {
      vulnerable: false,
      result,
      message: 'Explicit query construction and input validation protected against NoSQL injection.',
    };
  } catch (error: any) {
    return {
      vulnerable: false,
      result: null,
      message: `Error: ${error.message}. The query construction prevented execution of malicious code.`,
    };
  }
}

/**
 * Demonstrate injection attack attempt
 */
export async function demonstrateInjectionProtection(): Promise<{
  sqlInjection: any;
  nosqlInjection: any;
}> {
  // Simulate malicious input
  const maliciousSQLInput = "'; DROP TABLE test_data; --";
  const maliciousNoSQLInput = { $ne: null };

  const sqlResult = await simulateSQLInjection(maliciousSQLInput);
  const nosqlResult = await simulateNoSQLInjection(JSON.stringify(maliciousNoSQLInput));

  return {
    sqlInjection: sqlResult,
    nosqlInjection: nosqlResult,
  };
}

